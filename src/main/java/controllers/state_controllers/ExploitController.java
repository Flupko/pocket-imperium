package controllers.state_controllers;

import javafx.event.EventHandler;
import javafx.scene.input.MouseEvent;
import model.Partie;
import model.board.Board;
import model.board.Sector;
import model.players.Player;
import model.states.ExploitState;
import model.states.AbstractGameState;
import views.BoardView;
import views.components.action_components.ActionMenu;
import views.components.info_components.Instructions;
import views.components.board_components.SectorRegion;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.*;

/**
 * Contrôleur dédié à la phase d'exploitation (Exploit) dans le jeu.
 * Gère les interactions utilisateur pour scorer des secteurs spécifiques.
 * Ce contrôleur écoute les événements de la partie concernant les secteurs
 * possibles à scorer et met à jour la vue en conséquence. Il permet à
 * l'utilisateur de sélectionner un secteur pour y attribuer un score et
 * de confirmer l'action via le menu d'action.
 */
public class ExploitController implements PropertyChangeListener {
    private final Partie partie;
    private final Board board;
    private final HashMap<SectorRegion, EventHandler<MouseEvent>> sectorsEventsMap = new HashMap<>();
    private final HashMap<Sector, SectorRegion> sectorToRegionMap;
    private final Instructions instructions;
    private final ActionMenu actionMenu;

    /**
     * Secteur actuellement sélectionné par l'utilisateur pour le scoring.
     */
    private SectorRegion currentSelectedRegion;

    /**
     * Constructeur du contrôleur d'exploitation.
     * Initialise les composants nécessaires et configure les écouteurs d'événements.
     *
     * @param boardView        La vue principale du plateau de jeu.
     * @param sectorToRegionMap Mappage entre les secteurs du modèle et leurs représentations graphiques.
     */
    public ExploitController(BoardView boardView, HashMap<Sector, SectorRegion> sectorToRegionMap) {
        this.sectorToRegionMap = sectorToRegionMap;

        // Initialise l'état du jeu et les composants de la vue
        this.partie = Partie.getInstance();
        this.board = partie.getBoard();
        this.instructions = boardView.getInstructions();
        this.actionMenu = boardView.getActionMenu();

        // Écouteur pour le choix du secteur à scorer
        partie.addPropertyChangeListener("CHOOSE_SECTOR_SCORE", this);
    }

    /**
     * Gère les changements de propriétés observées.
     * Réagit spécifiquement à l'événement "CHOOSE_SECTOR_SCORE" pour mettre à jour la vue d'exploitation.
     *
     * @param evt L'événement de changement de propriété.
     */
    @Override
    public void propertyChange(PropertyChangeEvent evt) {
        Object newValue = evt.getNewValue();
        switch (evt.getPropertyName()) {
            case "CHOOSE_SECTOR_SCORE":
                if (newValue instanceof List<?>) {
                    updateBoardScoreSector((List<Sector>) newValue);
                }
                break;
        }
    }

    /**
     * Met à jour l'interface utilisateur pour la phase d'exploitation.
     * Met en évidence les secteurs valides pour le scoring et configure les gestionnaires d'événements.
     *
     * @param scorableSectors Liste des secteurs valides pour le scoring des navires.
     */
    private void updateBoardScoreSector(List<Sector> scorableSectors) {

        Player player = partie.getCurrentPlayer();

        for (Sector sector : scorableSectors) {
            SectorRegion sectorRegion = sectorToRegionMap.get(sector);
            sectorRegion.highlightRegion("#ffffffcc");
            EventHandler<MouseEvent> handler = event -> handleClickRectangleSector(sector, sectorRegion);
            sectorRegion.addEventHandler(MouseEvent.MOUSE_CLICKED, handler);
            sectorsEventsMap.put(sectorRegion, handler);
        }

        // Affiche les instructions pour le joueur
        instructions.setInstructions(player.getName() + ", choose a score to score.");
    }

    /**
     * Gère le clic sur une région sectorielle spécifique pour le scoring.
     *
     * @param sector      Le secteur sélectionné pour le scoring.
     * @param sectorRegion La région graphique du secteur sélectionné.
     */
    private void handleClickRectangleSector(Sector sector, SectorRegion sectorRegion) {
        if (currentSelectedRegion == sectorRegion) {
            deselectCurrentSector();
        } else {
            selectSector(sector, sectorRegion);
        }
    }

    /**
     * Sélectionne une région sectorielle pour le scoring et configure le menu d'action.
     *
     * @param sector        Le secteur sélectionné pour le scoring.
     * @param sectorRegion  La région graphique du secteur sélectionné.
     */
    private void selectSector(Sector sector, SectorRegion sectorRegion) {
        deselectCurrentSector();
        currentSelectedRegion = sectorRegion;
        currentSelectedRegion.setColoredBorder("blue");
        currentSelectedRegion.highlightRegion("#454545cc");

        // Configure le bouton d'action pour confirmer le scoring
        actionMenu.getActionButton().setOnMouseClicked(event -> handleClickScoreSector(sector, sectorRegion));
        actionMenu.showActionMenu(false, "",
                false, -1, -1, -1,
                true, "Score Sector");
    }

    /**
     * Désélectionne la région sectorielle actuellement sélectionnée et masque le menu d'action.
     */
    private void deselectCurrentSector() {
        if (currentSelectedRegion != null) {
            currentSelectedRegion.resetBorderToDefault();
            currentSelectedRegion.highlightRegion("#ffffffcc");
            currentSelectedRegion = null;
            instructions.setInstructions("");

            actionMenu.hideActionMenu();
            actionMenu.getActionButton().setOnMouseClicked(null);
        }
    }

    /**
     * Gère l'action de clic sur le bouton d'action pour scorer un secteur sélectionné.
     *
     * @param sector       Le secteur sélectionné pour le scoring.
     * @param sectorRegion La région graphique du secteur sélectionné.
     */
    private void handleClickScoreSector(Sector sector, SectorRegion sectorRegion) {
        ExploitState exploitState = getExploitState();
        if (exploitState == null) {
            return;
        }
        if (exploitState.canScoreSector(sector)) {
            finalizeScoredSector();
            exploitState.chooseSectorToScore(sector);
        } else {
            actionMenu.showInvalidEntry("Invalid entry.");
        }
    }

    /**
     * Finalise le scoring d'un secteur sélectionné en réinitialisant l'état de la vue.
     * Cela inclut la désélection du secteur, le nettoyage des effets visuels,
     * et la suppression des gestionnaires d'événements.
     */
    private void finalizeScoredSector() {
        deselectCurrentSector();
        clearVisualEffect();
        clearEventHandler();
    }

    /**
     * Supprime tous les gestionnaires d'événements associés aux régions sectorielles.
     * Cette méthode est utile pour réinitialiser l'état avant de configurer une nouvelle phase.
     */
    public void clearEventHandler() {
        for (Map.Entry<SectorRegion, EventHandler<MouseEvent>> entry : sectorsEventsMap.entrySet()) {
            SectorRegion sectorRegionWithEvent = entry.getKey();
            EventHandler<MouseEvent> handler = entry.getValue();
            sectorRegionWithEvent.removeEventHandler(MouseEvent.MOUSE_CLICKED, handler);
        }
        sectorsEventsMap.clear();
        currentSelectedRegion = null;
    }

    /**
     * Réinitialise les effets visuels appliqués aux régions sectorielles durant la phase.
     * Cette méthode nettoie les modifications visuelles pour préparer une nouvelle phase.
     */
    public void clearVisualEffect() {
        for (SectorRegion region : sectorsEventsMap.keySet()) {
            region.makeTransparent();
            region.resetBorderToDefault();
        }
    }

    /**
     * Récupère le state actuel d'exploitation si la phase de jeu est bien celle-ci.
     *
     * @return Le state d'exploitation courant ou {@code null} si ce n'est pas la phase d'exploitation.
     */
    private ExploitState getExploitState() {
        AbstractGameState state = partie.getCurrentGameState();
        if (state instanceof ExploitState exploitState) {
            return exploitState;
        }
        return null;
    }
}
