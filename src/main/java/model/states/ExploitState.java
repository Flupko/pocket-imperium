package model.states;

import model.Partie;
import model.board.Hex;
import model.board.Sector;
import model.players.Player;

import java.io.Serial;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * State gérant la phase Exploit du jeu.
 * Dans cette phase, on :
 * 1) Retire les ships qui ne peuvent être soutenus (removeUnsustainableShips).
 * 2) Score automatiquement les secteurs inoccupés (par défaut).
 * 3) Laisse chaque joueur choisir un secteur qu'il contrôle à scorer, si possible.
 * 4) Gère également un éventuel scoring supplémentaire pour le contrôleur de Tri-Prime.
 * Lorsqu'aucun secteur n'est plus éligible, on passe à la fin de round (EndRoundState).
 */
public class ExploitState extends AbstractGameState {

    /**
     * Identifiant de sérialisation pour garantir la compatibilité lors de la désérialisation.
     */
    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * Joueur actuel qui choisit un secteur à scorer, ou celui contrôlant Tri-Prime.
     */
    private Player player;

    /**
     * Indique combien de joueurs (plus éventuellement Tri-Prime) ont déjà exploité.
     */
    private int currentExploitCommandIndex = 0;

    /**
     * Constructeur de la classe ExploitState.
     * @param partie L'instance de la partie en cours.
     */
    public ExploitState(Partie partie) {
        super(partie);
    }

    /**
     * Méthode principale de la phase Exploit.
     * - Au premier passage (index=0), on retire les ships insoutenables et on score par défaut
     *   les secteurs inoccupés.
     * - Puis, chaque joueur choisit un secteur contrôlé à scorer, dans l'ordre.
     * - S'il reste un contrôleur de Tri-Prime, celui-ci choisit un secteur additionnel.
     * - Lorsque tout est scoré ou que plus aucun secteur n'est éligible, on passe en EndRoundState.
     */
    @Override
    public void execute() {
        if (currentExploitCommandIndex == 0) {
            board.removeUnsustainableShips();
            defaultScoreUnoccupiedSectors();
        }

        List<Sector> scorableSectors = getScorableSectors();

        // Si aucun secteur n'est plus éligible ou si on a fait (players.size() + 1) choix,
        // on réinitialise l'état "scoré" des secteurs et on passe à EndRoundState.
        if (scorableSectors.isEmpty() || currentExploitCommandIndex == players.size() + 1) {
            for (Sector sector : board.getSectors()) {
                sector.resetScored();
            }
            partie.transitionTo(new EndRoundState(partie));
            partie.runCurrentState();
            return;
        }

        // Le contrôleur de Tri-Prime a un scoring additionnel (index = players.size()).
        if (currentExploitCommandIndex == players.size()) {
            Hex triPrimeHex = board.getTriPrimeHex();
            if (!triPrimeHex.isOccupied()) {
                // S'il n'y a pas de contrôleur Tri-Prime, on passe directement à EndRoundState.
                partie.transitionTo(new EndRoundState(partie));
                partie.runCurrentState();
                return;
            }
            player = triPrimeHex.getController();
            partie.setCurrentPlayer(player);
        } else {
            // Sinon, on prend un joueur selon l'index
            partie.setCurrentPlayer(currentExploitCommandIndex);
            player = partie.getCurrentPlayer();
        }

        // On demande au joueur ou au contrôleur de Tri-Prime de choisir un secteur à scorer
        player.getStrategy().handleExploitChooseSector(this, scorableSectors);
    }

    /**
     * Permet au joueur de choisir un secteur à scorer.
     * @param sector Le secteur choisi par le joueur pour le scoring.
     */
    public void chooseSectorToScore(Sector sector) {
        if (canScoreSector(sector)) {
            sector.scoreSector(false); // false = pas en fin de partie
            currentExploitCommandIndex++;
        }
        // Retourne dans la logique pour continuer
        execute();
    }

    /**
     * Vérifie si un secteur est scorable (non encore scoré et occupé).
     * @param sector Le secteur à vérifier.
     * @return true si le secteur peut être scoré, false sinon.
     */
    public boolean canScoreSector(Sector sector) {
        return !sector.isScored() && sector.isOccupied();
    }

    /**
     * Retourne la liste des secteurs éligibles pour un scoring :
     * - Non centraux (pas Tri-Prime)
     * - Non encore scorés
     * - Occupés
     * @return Liste de secteurs scorable.
     */
    public List<Sector> getScorableSectors() {
        return Arrays.stream(board.getSectors())
                .filter(sector -> !sector.isCentralSector())
                .filter(sector -> !sector.isScored())
                .filter(Sector::isOccupied)
                .collect(Collectors.toList());
    }

    /**
     * Marque comme scorés (définitivement) tous les secteurs inoccupés,
     * évitant ainsi qu'ils soient choisis par un joueur.
     */
    public void defaultScoreUnoccupiedSectors() {
        Arrays.stream(board.getSectors())
                .filter(sector -> !sector.isOccupied())
                .forEach(Sector::setScored);
    }
}
